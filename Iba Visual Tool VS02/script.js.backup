// interactive 3d image cloud with selective bloom
import * as THREE from "three";
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

// bloom layer constant
const BLOOM_SCENE = 1;
const bloomLayer = new THREE.Layers();
bloomLayer.set(BLOOM_SCENE);

// scene components
let scene, camera, renderer, controls;
let bloomComposer, finalComposer;
let pointMeshes = [];
let pointData = [];

// material storage for bloom rendering
const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
const materials = {};

// raycasting for click detection
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// image parameters
let depthMultiplier = 400;
let pointSize = 2;
let dropoffBlack = 0;
let dropoffWhite = 0;
let resolution = 2;
let objectScale = 8;

// animation parameters
let animateRotation = true;
let rotationSpeed = 0.0015;
let rotationDirection = 1;
let verticalRotation = 0.001;

// bloom parameters
const bloomParams = {
  threshold: 0,
  strength: 1.5,
  radius: 0.5,
  exposure: 1
};

// gui instance
let gui;

init();
loadImageCloud();
setupGUI();

		void main() {

			vec4 mvPosition = modelViewMatrix * vec4( translate, 1.0 );
			vec3 trTime = vec3(translate.x + time,translate.y + time,translate.z + time);
			float scale =  sin( trTime.x * 2.1 ) + sin( trTime.y * 3.2 ) + sin( trTime.z * 4.3 );
			vScale = scale;
			scale = scale * 10.0 + 10.0;
			mvPosition.xyz += position * scale;
			vUv = uv;
			gl_Position = projectionMatrix * mvPosition;

		}
	</script>
	<script id="fshader" type="x-shader/x-fragment">
		precision highp float;

		uniform sampler2D map;

		varying vec2 vUv;
		varying float vScale;

		// HSL to RGB Conversion helpers
		vec3 HUEtoRGB(float H){
			H = mod(H,1.0);
			float R = abs(H * 6.0 - 3.0) - 1.0;
			float G = 2.0 - abs(H * 6.0 - 2.0);
			float B = 2.0 - abs(H * 6.0 - 4.0);
			return clamp(vec3(R,G,B),0.0,1.0);
		}

		vec3 HSLtoRGB(vec3 HSL){
			vec3 RGB = HUEtoRGB(HSL.x);
			float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;
			return (RGB - 0.5) * C + HSL.z;
		}

		void main() {
			vec4 diffuseColor = texture2D( map, vUv );
			gl_FragColor = vec4( diffuseColor.xyz * HSLtoRGB(vec3(vScale/5.0, 1.0, 0.5)), diffuseColor.w );

			if ( diffuseColor.w < 0.5 ) discard;
		}
	</script>


//////////////////////////////////////////////


<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing - unreal bloom selective</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> Click on a sphere to toggle bloom<br>By <a href="http://github.com/Temdog007" target="_blank" rel="noopener">Temdog007</a>
		</div>

		<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			void main() {

				gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

			}

		</script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
			import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

			const BLOOM_SCENE = 1;

			const bloomLayer = new THREE.Layers();
			bloomLayer.set( BLOOM_SCENE );

			const params = {
				threshold: 0,
				strength: 1,
				radius: 0.5,
				exposure: 1
			};

			const darkMaterial = new THREE.MeshBasicMaterial( { color: 'black' } );
			const materials = {};

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.toneMapping = THREE.ReinhardToneMapping;
			document.body.appendChild( renderer.domElement );

			const scene = new THREE.Scene();

			const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
			camera.position.set( 0, 0, 20 );
			camera.lookAt( 0, 0, 0 );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1;
			controls.maxDistance = 100;
			controls.addEventListener( 'change', render );

			const renderScene = new RenderPass( scene, camera );

			const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
			bloomPass.threshold = params.threshold;
			bloomPass.strength = params.strength;
			bloomPass.radius = params.radius;

			const bloomComposer = new EffectComposer( renderer );
			bloomComposer.renderToScreen = false;
			bloomComposer.addPass( renderScene );
			bloomComposer.addPass( bloomPass );

			const mixPass = new ShaderPass(
				new THREE.ShaderMaterial( {
					uniforms: {
						baseTexture: { value: null },
						bloomTexture: { value: bloomComposer.renderTarget2.texture }
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					defines: {}
				} ), 'baseTexture'
			);
			mixPass.needsSwap = true;

			const outputPass = new OutputPass();

			const finalComposer = new EffectComposer( renderer );
			finalComposer.addPass( renderScene );
			finalComposer.addPass( mixPass );
			finalComposer.addPass( outputPass );

			const raycaster = new THREE.Raycaster();

			const mouse = new THREE.Vector2();

			window.addEventListener( 'pointerdown', onPointerDown );

			const gui = new GUI();

			const bloomFolder = gui.addFolder( 'bloom' );

			bloomFolder.add( params, 'threshold', 0.0, 1.0 ).onChange( function ( value ) {

				bloomPass.threshold = Number( value );
				render();

			} );

			bloomFolder.add( params, 'strength', 0.0, 3 ).onChange( function ( value ) {

				bloomPass.strength = Number( value );
				render();

			} );

			bloomFolder.add( params, 'radius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {

				bloomPass.radius = Number( value );
				render();

			} );

			const toneMappingFolder = gui.addFolder( 'tone mapping' );

			toneMappingFolder.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {

				renderer.toneMappingExposure = Math.pow( value, 4.0 );
				render();

			} );

			setupScene();

			function onPointerDown( event ) {

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );
				const intersects = raycaster.intersectObjects( scene.children, false );
				if ( intersects.length > 0 ) {

					const object = intersects[ 0 ].object;
					object.layers.toggle( BLOOM_SCENE );
					render();

				}

			}

			window.onresize = function () {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

				bloomComposer.setSize( width, height );
				finalComposer.setSize( width, height );

				render();

			};

			function setupScene() {

				scene.traverse( disposeMaterial );
				scene.children.length = 0;

				const geometry = new THREE.IcosahedronGeometry( 1, 15 );

				for ( let i = 0; i < 50; i ++ ) {

					const color = new THREE.Color();
					color.setHSL( Math.random(), 0.7, Math.random() * 0.2 + 0.05 );

					const material = new THREE.MeshBasicMaterial( { color: color } );
					const sphere = new THREE.Mesh( geometry, material );
					sphere.position.x = Math.random() * 10 - 5;
					sphere.position.y = Math.random() * 10 - 5;
					sphere.position.z = Math.random() * 10 - 5;
					sphere.position.normalize().multiplyScalar( Math.random() * 4.0 + 2.0 );
					sphere.scale.setScalar( Math.random() * Math.random() + 0.5 );
					scene.add( sphere );

					if ( Math.random() < 0.25 ) sphere.layers.enable( BLOOM_SCENE );

				}

				render();

			}

			function disposeMaterial( obj ) {

				if ( obj.material ) {

					obj.material.dispose();

				}

			}

			function render() {

				scene.traverse( darkenNonBloomed );
				bloomComposer.render();
				scene.traverse( restoreMaterial );

				// render the entire scene, then render bloom scene on top
				finalComposer.render();

			}

			function darkenNonBloomed( obj ) {

				if ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {

					materials[ obj.uuid ] = obj.material;
					obj.material = darkMaterial;

				}

			}

			function restoreMaterial( obj ) {

				if ( materials[ obj.uuid ] ) {

					obj.material = materials[ obj.uuid ];
					delete materials[ obj.uuid ];

				}

			}

		</script>

	</body>

</html>

///////////////////////////////////////

import { HalftonePass } from 'three/addons/postprocessing/HalftonePass.js';

      				const halftonePass = new HalftonePass( params );
				composer.addPass( renderPass );
				composer.addPass( halftonePass );

				window.onresize = function () {

					// resize composer
					renderer.setSize( window.innerWidth, window.innerHeight );
					composer.setSize( window.innerWidth, window.innerHeight );
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

				};


/////////////////////////////////////////

composer4 = new EffectComposer( renderer, new THREE.WebGLRenderTarget( rtWidth, rtHeight, rtParameters ) );

				composer4.addPass( renderScene );
				composer4.addPass( gammaCorrection );
				composer4.addPass( effectBloom );
				composer4.addPass( effectFilm );
				composer4.addPass( effectBleach );
				composer4.addPass( effectVignette );

				renderScene.uniforms[ 'tDiffuse' ].value = composerScene.renderTarget2.texture;

				window.addEventListener( 'resize', onWindowResize );

//////////////////////////////////////

import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";

let scene, camera, renderer, points;
let pointData = [];
let depthMultiplier = 400;
let pointSize = 4;
let dropoffBlack = 0;
let dropoffWhite = 0;
let isEllipse = false;

let animateRotation = true;
let rotationSpeed = 0.0015;
let rotationDirection = 1;
let verticalRotation = 0.001;

let resolution = 1;     // 1 = full resolution
let objectScale = 8;    // multiplier for x/y coordinates

init();
loadImageCloud();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
  camera.position.z = 800;

  renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("canvas"), antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Event listeners
  document.getElementById("depthSlider").addEventListener("input", e => { depthMultiplier = +e.target.value; rebuildGeometry(); });
  document.getElementById("pointSizeSlider").addEventListener("input", e => { pointSize = +e.target.value; updatePointMaterial(); });
  document.getElementById("dropoffBlackSlider").addEventListener("input", e => { dropoffBlack = +e.target.value; rebuildGeometry(); });
  document.getElementById("dropoffWhiteSlider").addEventListener("input", e => { dropoffWhite = +e.target.value; rebuildGeometry(); });
  document.getElementById("toggleShape").addEventListener("click", () => { isEllipse = !isEllipse; document.getElementById("toggleShape").textContent = isEllipse ? "Square" : "Ellipse"; updatePointMaterial(); });
  document.getElementById("toggleAnimation").addEventListener("click", () => { animateRotation = !animateRotation; document.getElementById("toggleAnimation").textContent = animateRotation ? "Pause" : "Play"; });
  document.getElementById("speedSlider").addEventListener("input", e => { rotationSpeed = +e.target.value; });
  document.getElementById("directionSlider").addEventListener("input", e => { rotationDirection = +e.target.value; });
  document.getElementById("verticalRotationSlider").addEventListener("input", e => { verticalRotation = +e.target.value; });
  document.getElementById("randomizeButton").addEventListener("click", randomizeSettings);
  document.getElementById("resolutionSlider").addEventListener("input", e => { resolution = +e.target.value; rebuildGeometry(); });
  document.getElementById("objectScaleSlider").addEventListener("input", e => { objectScale = +e.target.value; rebuildGeometry(); });

  // Image upload
  document.getElementById("imageUpload").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
      loadImageCloud(event.target.result);
    };
    reader.readAsDataURL(file);
  });
}

// Create point texture
function createPointTexture(isEllipse) {
  const size = 64;
  const canvas = document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext("2d");

  ctx.clearRect(0, 0, size, size);
  ctx.fillStyle = "white";

  if (isEllipse) {
    ctx.beginPath();
    ctx.ellipse(size/2, size/2, size/2, size/2, 0, 0, 2*Math.PI); // circle
    ctx.fill();
  } else {
    ctx.fillRect(0, 0, size, size);
  }

  return new THREE.CanvasTexture(canvas);
}

function loadImageCloud(src) {
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = src || "https://freight.cargo.site/w/1500/q/75/i/N2172233884443262099351353689255/Post_Slide01.jpg";

  img.onload = () => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    const scale = 0.1;
    const w = (canvas.width = Math.floor(img.width * scale));
    const h = (canvas.height = Math.floor(img.height * scale));

    ctx.drawImage(img, 0, 0, w, h);
    const imgData = ctx.getImageData(0, 0, w, h).data;

    pointData = [];
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y*w + x)*4;
        const r = imgData[i]/255;
        const g = imgData[i+1]/255;
        const b = imgData[i+2]/255;
        const brightness = (r+g+b)/3;
        pointData.push({ x, y, r, g, b, brightness });
      }
    }

    rebuildGeometry();
    camera.position.z = Math.max(w,h)*5;
  };
}

function rebuildGeometry() {
  if (points) scene.remove(points);

  const vertices = [];
  const colors = [];

  const h = Math.max(...pointData.map(p => p.y))+1;
  const w = Math.max(...pointData.map(p => p.x))+1;

  for (let y = 0; y < h; y += resolution) {
    for (let x = 0; x < w; x += resolution) {
      const p = pointData.find(pt => pt.x === x && pt.y === y);
      if(!p) continue;
      if(p.brightness <= dropoffBlack || p.brightness >= 1 - dropoffWhite) continue;
      vertices.push((p.x - w/2) * objectScale, (-p.y + h/2) * objectScale, (p.brightness-0.5)*depthMultiplier);
      colors.push(p.r, p.g, p.b);
    }
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices,3));
  geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors,3));

  const material = new THREE.PointsMaterial({
    size: pointSize*4,
    vertexColors:true,
    map:createPointTexture(isEllipse),
    transparent:true,
    alphaTest:0.5
  });

  points = new THREE.Points(geometry, material);
  scene.add(points);
}

function updatePointMaterial() {
  if (!points) return;
  points.material.size = pointSize*4;
  points.material.map = createPointTexture(isEllipse);
  points.material.needsUpdate = true;
}

function updatePointsDepth() {
  if (!points) return;
  const positions = points.geometry.attributes.position.array;
  for (let i=0;i<positions.length/3;i++){
    const brightness = positions[i*3+2]/depthMultiplier + 0.5; // reverse formula
    positions[i*3+2] = (brightness-0.5)*depthMultiplier;
  }
  points.geometry.attributes.position.needsUpdate=true;
}

function randomizeSettings() {
  depthMultiplier=Math.random()*800+100;
  document.getElementById("depthSlider").value=depthMultiplier;

  pointSize=Math.random()*15+1;
  document.getElementById("pointSizeSlider").value=pointSize;

  dropoffBlack=Math.random()*0.3;
  document.getElementById("dropoffBlackSlider").value=dropoffBlack;

  dropoffWhite=Math.random()*0.3;
  document.getElementById("dropoffWhiteSlider").value=dropoffWhite;

  rotationSpeed=Math.random()*0.02;
  document.getElementById("speedSlider").value=rotationSpeed;

  rotationDirection=Math.random()>0.5?1:-1;
  document.getElementById("directionSlider").value=rotationDirection;

  verticalRotation=(Math.random()-0.5)*0.02;
  document.getElementById("verticalRotationSlider").value=verticalRotation;

  resolution = Math.floor(Math.random()*10)+1;
  document.getElementById("resolutionSlider").value = resolution;

  objectScale = Math.random()*15+1;
  document.getElementById("objectScaleSlider").value = objectScale;

  isEllipse=Math.random()>0.5;
  document.getElementById("toggleShape").textContent=isEllipse?"Square":"Ellipse";

  rebuildGeometry();
}

function animate() {
  requestAnimationFrame(animate);
  if(points && animateRotation){
    points.rotation.y+=rotationSpeed*rotationDirection;
    points.rotation.x+=verticalRotation;
  }
  renderer.render(scene,camera);
}